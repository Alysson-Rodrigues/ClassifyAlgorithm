# this algorithm takes a string and returns a list of the words in alphabetical order. it does it by using a dictionary ('numAlphabet')
# to define the value of each character in the string. It will be updated as i learn python methods and functions, making possible to
# change the dictionary based on JSON files, split words by another characters but spaces and decide the order of the result when calling the sort function




numAlphabet = {" ": -1, "a": 0,
               "b": 1, "c": 2, "d": 3, "e": 4, "f": 5, "g": 6, "h": 7, "i": 8, "j": 9, "k": 10, "l": 11, "m": 12, "n": 13, "o": 14, "p": 15, "q": 16, "r": 17, "s": 18, "t": 19, "u": 20, "v": 21, "w": 22, "x": 23, "y": 24, "z": 25, ",": 26, ".": 27, }


def classify(string):
    
    string = string.lower()
    score = 0


    # If the string is just a single character, it gives it a score immediately
    if len(string) == 1:
        score = numAlphabet[string]
        return score


    # If the string is not a single character, puntuate it lettter by letter
    else:
        index = 0
        endscore = []
        for i in string:
            # this loop creates a list with a numerical score for each letter in the string instead of pontuate words, this prevents mistakes like score "AZ" Higher than "BB"
            endscore.append(numAlphabet[i])
            index = index + 1
    return endscore

# this method expects two lists of numbers - the scores generated by "classify" function - and returns a boolean value,
# that tells if the two words need to be switched in the list or not.
def verifySwitch(factor1, factor2):
    

    # If one or both words are integers(instead of lists), they could break the algorithm because they cannot be iterated by loops, so i
    # we take care of them using nested if and else statements.
    if type(factor1) is int and type(factor2) is int:
        if factor1 < factor2:
            return True
        else:
            return False
    if type(factor1) is int:
        if factor1 <= factor2[0]:
            return False
        else:
            return True
    if type(factor2) is int:
        if factor2 <= factor1[0]:
            return True
        else:
            return False


    # Now, without integers in the game, we use loops to compare the pontuations letter by letter, using a index to make only useful comparisons,
    # once we dont want to compare a letter in the first word with ALL the letters in the second one.
    index = 0
    for i in factor1:

        ## the first if statement prevents the program from crashing when processing names who are part if another names, like
        # Alex and Alexsander, and follows the alphabetical order placing the name with less characters first
        if index == len(factor2):
            return True
        if i < factor2[index]:
            return False
        elif i > factor2[index]:
            return True
        elif factor1 == factor2:
            return False
        index += 1


def sort(string):
    sentence = string.split(' ')

    # This loops creates a alternative list with the given words and gives them a score using 'classify' function
    classifiedSentence = []
    for i in sentence:
        classifiedSentence.append(classify(i))


    changesNeeded = 100000
    while changesNeeded > 0:
        index = 0
        for x in classifiedSentence:

            if index > len(classifiedSentence) - 2:
                changesNeeded += 1
                break
            elif verifySwitch(x, classifiedSentence[index+1]) == True:

                newFirstClasfd = classifiedSentence[index + 1]
                newSecondClasfd = classifiedSentence[index]
                classifiedSentence[index] = newFirstClasfd
                classifiedSentence[index + 1] = newSecondClasfd

                newFirst = sentence[index + 1]
                newSecond = sentence[index]
                sentence[index] = newFirst
                sentence[index + 1] = newSecond

                index += 1
                changesNeeded += len(sentence)
            elif index > len(classifiedSentence) - 2:
                changesNeeded += 1
                index += 1
                break
            elif verifySwitch(x, classifiedSentence[index+1]) == False:
                index += 1
        changesNeeded -= 1
    return sentence


print(sort('Nao e necessario criar um texto apenas pra o teste desse algoritmo e basta colocar o numero de palavras suficiente pra que ele mostre seu real limite e valor para que entendamos a maravilha de sua criacao'))
